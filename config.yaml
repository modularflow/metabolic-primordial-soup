# BFF Primordial Soup - TAPE-BASED Energy Model
# ==============================================
#
# Programs evolve near energy zones which act as "batteries" filled with @.
# Energy is purely positional on the tape - @ must IMMEDIATELY PRECEDE an 
# operation for it to execute. No external counters or fuel pools.
#
# Energy rules:
#   - When IP lands on @: consume it (→0), peek next byte:
#       - If next byte is a BFF op: execute it, advance IP by 2
#       - Otherwise: just advance IP by 1
#   - When IP lands directly on BFF op: skip it (treated as NOP)
#   - $ only converts to @ if a head points at @ on the OTHER tape half
#
# This creates strong evolutionary pressure for programs to interleave
# @ symbols with operations (e.g., @+@-@. executes all three ops)
#
# Run: ./target/release/energetic-primordial-soup --config config.yaml

# Compute backend: "cuda" (NVIDIA), "wgpu" (cross-platform), "cpu" (fallback)
backend: "cuda"

# Grid dimensions (2D toroidal grid)
grid:
  width: 32
  height: 16

# Simulation parameters
simulation:
  seed: 42
  mutation_rate: 2048       # 1 in N chance per byte (higher = less mutation)
  steps_per_run: 8192       # Max BFF steps per epoch (limited by energy)
  max_epochs: 10000000
  neighbor_range: 2         # Pairing range (2 = 5x5 neighborhood)
  parallel_sims: 3072           # Parallel simulations on GPU
  parallel_layout: [64, 48]   # Grid arrangement [cols, rows]
  border_interaction: true  # Cross-simulation pairing (mega-sim mode)
  border_thickness: 2        # Dead zone between simulations

# Output
# Also saves interval_metrics.csv with ops count per frame interval
output:
  frame_interval: 10000      # Save frame every N epochs (0 = disabled)
  frames_dir: "frames"     # Also saves interval_metrics.csv here
  frame_format: "jpg"      # Format: "png", "jpg"/"jpeg", or "ppm"
  thumbnail_scale: 1
  save_raw: false
  raw_dir: "raw_data"
  async_save: true
  render_frames: true
  mega_only: true          # Only save mega-simulation frame, skip individual sim frames

# Checkpoints
checkpoint:
  enabled: false
  interval: 100000
  path: "checkpoints"
  resume_from: ""

# =============================================================================
# TAPE-BASED ENERGY MODEL
# =============================================================================
#
# How it works:
#   1. Energy zones are filled with @ (stored energy) every epoch
#   2. Programs IN zones get overwritten - they can't live there
#   3. Programs NEAR zones can harvest @ using the $ command
#   4. @ must IMMEDIATELY PRECEDE an operation for it to execute
#   5. Operations without preceding @ are skipped (NOPs)
#   6. $ command: harvests @ from other tape half (cross-tape interaction)
#
# Evolution pressure:
#   - Programs must stay near energy zones
#   - Programs that interleave @ with operations can execute
#   - Programs that efficiently use $ to harvest from neighbors survive
#   - Pattern "@+@-@." executes +, -, . while "@@@+++" only executes one +
#
energy:
  enabled: true
  
  # Energy zone configuration
  sources: 8                # Number of zones: 1=center, 4=corners, 8=all edges
  radius: 2                # Zone radius (smaller = more pressure)
  shape: "random"           # Zone shape: circle, strip_h, strip_v, ellipse, random
  
  # Death mechanics (disabled - energy model handles liveness)
  death_epochs: 0            # Epochs without interaction → death (0 = immortal)
  reserve_epochs: 10         # Grace period after receiving a copy
  spontaneous_rate: 500      # 1/N chance for dead tape to respawn (0 = disabled)
  
  # Dynamic zones (optional)
  dynamic:
    random_placement: false
    max_sources: 16
    source_lifetime: 0      # 0 = permanent
    spawn_rate: 0           # 0 = no new sources

# Metrics (phase transition detection)
metrics:
  enabled: true
  interval: 1000
  output_file: "metrics.csv"
  brotli_quality: 4

# =============================================================================
# PRESETS
# =============================================================================
#
# High pressure (fast evolution, small populations):
#   sources: 4, radius: 8, spontaneous_rate: 100
#
# Low pressure (slow evolution, large populations):  
#   sources: 8, radius: 32, spontaneous_rate: 1000
#
# Note: death_epochs is disabled (0) - program liveness is now determined
# purely by whether they have @ symbols preceding their operations.
# Programs without interleaved @-ops will simply not execute.
